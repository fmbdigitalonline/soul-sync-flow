
/**
 * OpenAI Agent Orchestrator - Core multi-agent system for HACS Growth Mode
 * Implements Tree-of-Thought reasoning with role-based agents
 */

import { LayeredBlueprint } from '@/types/personality-modules';
import { LifeDomain } from '@/types/growth-program';
import { supabase } from '@/integrations/supabase/client';

interface AgentRole {
  name: string;
  systemPrompt: string;
  tools?: OpenAITool[];
}

interface OpenAITool {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: object;
  };
}

interface AgentMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string;
  tool_calls?: any[];
  tool_call_id?: string;
}

interface ReasoningNode {
  id: string;
  thought: string;
  confidence: number;
  children: ReasoningNode[];
  evaluation?: number;
}

export class OpenAIAgentOrchestrator {
  private apiKey: string;
  private baseURL = 'https://api.openai.com/v1';

  constructor() {
    // In browser environment, we'll need to use edge functions for API calls  
    this.apiKey = '';
  }

  // Agent Role Definitions aligned with HACS modules
  private getAgentRoles(): Record<string, AgentRole> {
    return {
      planner: {
        name: 'Blueprint-Aware Planner',
        systemPrompt: `You are the Planner Agent in the HACS (Hermetic AI Cognitive Stack). Your role:

1. Design personalized growth plans using Tree-of-Thought reasoning
2. Integrate blueprint data (MBTI, Human Design, Astrology, Numerology) into every decision
3. Generate multiple plan branches and evaluate them systematically
4. Focus on sustainable, rhythm-aligned action steps

Always consider:
- User's cognitive temperament and energy strategy
- Natural cycles and timing preferences
- Past feedback and adaptation patterns
- Current life context and constraints

Output structured plans with reasoning traces.`,
        tools: [
          {
            type: 'function',
            function: {
              name: 'generate_plan_branches',
              description: 'Generate multiple alternative plan approaches using Tree-of-Thought',
              parameters: {
                type: 'object',
                properties: {
                  domain: { type: 'string' },
                  timeline: { type: 'string' },
                  blueprint_context: { type: 'object' },
                  current_state: { type: 'object' }
                },
                required: ['domain', 'timeline', 'blueprint_context']
              }
            }
          }
        ]
      },

      reflector: {
        name: 'Quality & Alignment Reflector',
        systemPrompt: `You are the Reflection Agent in HACS. Your role:

1. Critically evaluate plans generated by the Planner
2. Check alignment with user's blueprint and past preferences
3. Identify potential sustainability issues or misalignments
4. Suggest refinements that honor the user's authentic nature

Evaluation criteria:
- Blueprint alignment (does this honor their cognitive style?)
- Sustainability (can they maintain this given their energy patterns?)
- Personalization (is this uniquely theirs, not generic advice?)
- Growth edge (does this stretch them appropriately?)

Provide constructive feedback with specific improvement suggestions.`,
        tools: [
          {
            type: 'function',
            function: {
              name: 'evaluate_plan_alignment',
              description: 'Evaluate how well a plan aligns with user blueprint and constraints',
              parameters: {
                type: 'object',
                properties: {
                  plan: { type: 'object' },
                  blueprint: { type: 'object' },
                  past_feedback: { type: 'array' },
                  evaluation_criteria: { type: 'array' }
                },
                required: ['plan', 'blueprint']
              }
            }
          }
        ]
      },

      memory_updater: {
        name: 'Adaptive Memory Updater',
        systemPrompt: `You are the Memory Updater Agent in HACS. Your role:

1. Process user feedback and behavioral data into learnings
2. Update the dynamic blueprint based on new patterns
3. Detect blueprint drift and evolution
4. Maintain context continuity across sessions

Focus on:
- Implicit feedback from user behavior (edits, skips, delays)
- Explicit feedback (ratings, comments, modifications)
- Pattern changes over time
- Preference evolution

Update memory structures to improve future planning.`,
        tools: [
          {
            type: 'function',
            function: {
              name: 'update_user_memory',
              description: 'Update user memory with new behavioral patterns and feedback',
              parameters: {
                type: 'object',
                properties: {
                  user_id: { type: 'string' },
                  feedback_data: { type: 'object' },
                  behavioral_signals: { type: 'object' },
                  memory_type: { type: 'string' }
                },
                required: ['user_id', 'feedback_data']
              }
            }
          }
        ]
      },

      delivery: {
        name: 'Contextual Delivery Agent',
        systemPrompt: `You are the Delivery Agent in HACS. Your role:

1. Format plans for optimal user experience
2. Adapt communication style to user's blueprint
3. Add motivational context and reasoning
4. Ensure actionability and clarity

Communication style adaptation:
- MBTI thinking types: logical explanations, systematic breakdowns
- MBTI feeling types: personal meaning, values alignment
- HD Manifestors: direct, concise, action-oriented
- HD Generators: energizing, response-based framing

Make every interaction feel personally crafted and meaningful.`,
        tools: [
          {
            type: 'function',
            function: {
              name: 'format_personalized_delivery',
              description: 'Format content with personalized communication style',
              parameters: {
                type: 'object',
                properties: {
                  content: { type: 'object' },
                  blueprint: { type: 'object' },
                  delivery_context: { type: 'string' },
                  urgency_level: { type: 'string' }
                },
                required: ['content', 'blueprint']
              }
            }
          }
        ]
      }
    };
  }

  // Tree-of-Thought Implementation
  async generateWithTreeOfThought(
    prompt: string,
    blueprint: LayeredBlueprint,
    domain: LifeDomain,
    depth: number = 3
  ): Promise<ReasoningNode> {
    console.log('🌳 Starting Tree-of-Thought reasoning for growth planning');

    const rootNode: ReasoningNode = {
      id: 'root',
      thought: prompt,
      confidence: 1.0,
      children: []
    };

    // Generate initial thought branches
    const branches = await this.generateThoughtBranches(prompt, blueprint, domain, depth);
    rootNode.children = branches;

    // Evaluate and prune branches
    await this.evaluateBranches(rootNode, blueprint, domain);

    // Select best path
    const bestPath = this.selectBestPath(rootNode);
    
    console.log('✅ Tree-of-Thought reasoning complete, best path selected');
    return bestPath;
  }

  private async generateThoughtBranches(
    thought: string,
    blueprint: LayeredBlueprint,
    domain: LifeDomain,
    depth: number
  ): Promise<ReasoningNode[]> {
    if (depth === 0) return [];

    const response = await this.callOpenAI({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `Generate 3 distinct approaches to this growth planning challenge. 
          Consider the user's blueprint: ${JSON.stringify(blueprint, null, 2)}
          Domain: ${domain}
          
          For each approach, provide:
          1. Core strategy
          2. Confidence level (0-1)
          3. Unique advantages
          4. Potential challenges`
        },
        {
          role: 'user',
          content: thought
        }
      ],
      temperature: 0.8
    });

    // Parse response into structured branches
    const branches = this.parseIntoBranches(response.choices[0].message.content || '');
    
    // Recursively generate children for each branch
    for (const branch of branches) {
      if (depth > 1) {
        branch.children = await this.generateThoughtBranches(
          branch.thought,
          blueprint,
          domain,
          depth - 1
        );
      }
    }

    return branches;
  }

  private async evaluateBranches(
    node: ReasoningNode,
    blueprint: LayeredBlueprint,
    domain: LifeDomain
  ): Promise<void> {
    for (const child of node.children) {
      // Use Reflector agent to evaluate this branch
      const evaluation = await this.runAgent('reflector', [
        {
          role: 'user',
          content: `Evaluate this growth approach:
          ${child.thought}
          
          Blueprint context: ${JSON.stringify(blueprint, null, 2)}
          Domain: ${domain}
          
          Rate 0-10 on: alignment, sustainability, personalization, growth potential`
        }
      ]);

      child.evaluation = this.parseEvaluationScore(evaluation);
      
      // Recursively evaluate children
      if (child.children.length > 0) {
        await this.evaluateBranches(child, blueprint, domain);
      }
    }
  }

  private selectBestPath(node: ReasoningNode): ReasoningNode {
    if (node.children.length === 0) return node;

    // Select child with highest evaluation score
    const bestChild = node.children.reduce((best, current) => 
      (current.evaluation || 0) > (best.evaluation || 0) ? current : best
    );

    return this.selectBestPath(bestChild);
  }

  // Agent Execution
  async runAgent(
    agentType: string, 
    messages: AgentMessage[],
    context?: any
  ): Promise<string> {
    const agent = this.getAgentRoles()[agentType];
    if (!agent) throw new Error(`Unknown agent type: ${agentType}`);

    const systemMessage: AgentMessage = {
      role: 'system',
      content: agent.systemPrompt
    };

    const response = await this.callOpenAI({
      model: 'gpt-4o-mini',
      messages: [systemMessage, ...messages],
      tools: agent.tools,
      temperature: agentType === 'planner' ? 0.8 : 0.3
    });

    return response.choices[0].message.content || '';
  }

  // Multi-Agent Collaboration Flow
  async orchestrateGrowthPlan(
    userId: string,
    domain: LifeDomain,
    blueprint: LayeredBlueprint,
    currentState: any,
    pastFeedback: any[] = []
  ): Promise<any> {
    console.log('🎭 Starting multi-agent growth plan orchestration');

    try {
      // Step 1: Planner generates initial plan using Tree-of-Thought
      const planningPrompt = `Create a personalized growth plan for domain: ${domain}
      
      User blueprint: ${JSON.stringify(blueprint, null, 2)}
      Current state: ${JSON.stringify(currentState, null, 2)}
      Past feedback: ${JSON.stringify(pastFeedback, null, 2)}`;

      const thoughtTree = await this.generateWithTreeOfThought(
        planningPrompt,
        blueprint,
        domain
      );

      const initialPlan = await this.runAgent('planner', [
        {
          role: 'user',
          content: `Based on this reasoning: ${thoughtTree.thought}, create a detailed growth plan.`
        }
      ]);

      // Step 2: Reflector evaluates and suggests improvements
      const reflection = await this.runAgent('reflector', [
        {
          role: 'user',
          content: `Review this plan: ${initialPlan}`
        }
      ]);

      // Step 3: Planner refines based on reflection
      const refinedPlan = await this.runAgent('planner', [
        {
          role: 'user',
          content: `Refine this plan based on feedback: ${reflection}
          Original plan: ${initialPlan}`
        }
      ]);

      // Step 4: Delivery agent formats for user
      const finalDelivery = await this.runAgent('delivery', [
        {
          role: 'user',
          content: `Format this plan for delivery: ${refinedPlan}
          Blueprint: ${JSON.stringify(blueprint, null, 2)}`
        }
      ]);

      console.log('✅ Multi-agent orchestration complete');
      
      return {
        plan: this.parsePlanFromDelivery(finalDelivery),
        reasoning: thoughtTree,
        reflection: reflection,
        metadata: {
          generated_at: new Date().toISOString(),
          agents_used: ['planner', 'reflector', 'delivery'],
          blueprint_version: blueprint.user_meta?.created_at
        }
      };

    } catch (error) {
      console.error('❌ Agent orchestration failed:', error);
      throw error;
    }
  }

  // Feedback Processing
  async processFeedback(
    userId: string,
    feedback: any,
    behavioralSignals: any
  ): Promise<void> {
    await this.runAgent('memory_updater', [
      {
        role: 'user',
        content: `Process this feedback and update user memory:
        
        Feedback: ${JSON.stringify(feedback, null, 2)}
        Behavioral signals: ${JSON.stringify(behavioralSignals, null, 2)}
        User ID: ${userId}`
      }
    ]);
  }

  // OpenAI API Integration via Edge Function
  private async callOpenAI(params: any): Promise<any> {
    try {
      console.log('🤖 Calling OpenAI via Edge Function...');
      console.log('📤 Request params:', JSON.stringify(params, null, 2));
      
      const { data, error } = await supabase.functions.invoke('openai-agent', {
        body: {
          messages: params.messages,
          model: params.model || 'gpt-4o-mini',
          temperature: params.temperature || 0.7,
          tools: params.tools
        }
      });

      console.log('📥 Edge Function response - data:', JSON.stringify(data, null, 2));
      console.log('📥 Edge Function response - error:', error);

      if (error) {
        console.error('❌ Edge Function error:', error);
        throw new Error(`Agent API error: ${error.message}`);
      }

      if (!data) {
        console.error('❌ No data returned from Edge Function');
        throw new Error('No data returned from Edge Function');
      }

      if (!data.content) {
        console.error('❌ No content in response data:', data);
        throw new Error('No content returned from agent');
      }

      if (typeof data.content !== 'string' || data.content.trim() === '') {
        console.error('❌ Invalid content format:', typeof data.content, 'length:', data.content?.length);
        throw new Error('Invalid or empty content returned from agent');
      }

      // Format response to match expected structure
      return {
        choices: [{
          message: {
            content: data.content
          }
        }],
        usage: data.usage,
        model: data.model
      };
    } catch (error) {
      console.error('❌ OpenAI Agent call failed:', error);
      throw error;
    }
  }

  // Parsing Utilities
  private parseIntoBranches(content: string): ReasoningNode[] {
    // Simple parsing - in production, use more sophisticated parsing
    const branches: ReasoningNode[] = [];
    const lines = content.split('\n').filter(line => line.trim());
    
    for (let i = 0; i < Math.min(3, lines.length); i++) {
      branches.push({
        id: `branch_${i}`,
        thought: lines[i],
        confidence: 0.7 + (Math.random() * 0.3), // Placeholder
        children: []
      });
    }
    
    return branches;
  }

  private parseEvaluationScore(evaluation: string): number {
    // Extract numeric score from evaluation text
    const match = evaluation.match(/(\d+(?:\.\d+)?)/);
    return match ? parseFloat(match[1]) / 10 : 0.5;
  }

  private parsePlanFromDelivery(delivery: string): any {
    // Parse structured plan from delivery text
    // This would be more sophisticated in production
    return {
      formatted_content: delivery,
      extracted_actions: [],
      timeline: 'weekly',
      personalization_level: 'high'
    };
  }

  // Test method for immediate debugging
  async testSimpleCall(): Promise<string> {
    try {
      console.log('🧪 Testing simple OpenAI call...');
      
      const result = await this.callOpenAI({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'You are a helpful assistant. Respond with exactly one short sentence.'
          },
          {
            role: 'user',
            content: 'Say hello and confirm you are working.'
          }
        ],
        temperature: 0.3
      });

      console.log('🧪 Test call result:', result);
      return result.choices[0].message.content || 'No content';

    } catch (error) {
      console.error('🧪 Test call failed:', error);
      throw error;
    }
  }
}

export const openAIAgentOrchestrator = new OpenAIAgentOrchestrator();
